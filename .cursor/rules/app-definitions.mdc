---
alwaysApply: false
---

## **Volleyball Score & Statistics App – Final Technical Design Document**

_Target platform: **React Native (Expo)** · Language: **TypeScript** · State: **Zustand + Immer** · Validation: **Zod**_  
_Last updated: **26 Jul 2025**_

---

### **1 · Executive Summary**

A mobile app that lets two volleyball teams keep score in real time, auto‑generate balanced teams, store every finished match locally, and surface basic player/match statistics.  
_Key goals_: **offline‑first**, **extensible**, **undoable**, and **cleanly layered** so that a cloud backend can be plugged in later without rewriting the core logic.

---

### **2 · Functional Requirements**

| #    | Requirement                                                                                                                                               | Notes |
| ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- |
| FR‑1 | Split‑screen **Score** view; tap left/right to add a point to Team A or Team B.                                                                           |
| FR‑2 | **Undo / redo** of up to **200** actions (points, setting changes, etc.).                                                                                 |
| FR‑3 | **Game‑over rule**: match ends when a team reaches `pointsToWin` **and** is ahead by `winBy` points. Both values are user‑configurable (defaults 25 / 2). |
| FR‑4 | **Continuous match clock** visible on Score screen.                                                                                                       |
| FR‑5 | **Team generator** that creates random or win‑rate‑balanced teams from the player pool.                                                                   |
| FR‑6 | **Match history** stored locally; tappable list with detail view.                                                                                         |
| FR‑7 | **Statistics v‑1**: per‑player win‑rate, longest win streak, average match length.                                                                        |
| FR‑8 | **Settings** screen for points‑to‑win, win‑by, theme, haptics/sounds, etc.                                                                                |
| FR‑9 | **Extensibility**: new sports, online sync, or extra analytics must plug in via well‑defined interfaces.                                                  |

_Non‑functional_: ≥60 fps UI, domain‑layer test coverage ≥ 80 %.

---

### **3 · Architecture Overview**

```
┌────────────────────────────┐
│  Presentation (React UI)   │  ➜ React Native components & hooks
└─────────────┬──────────────┘
              │ dispatches Commands via store hooks
┌─────────────▼──────────────┐
│  Application / Store       │  ➜ Zustand + custom undo middleware
└─────────────┬──────────────┘
              │ operates only on pure TypeScript
┌─────────────▼──────────────┐
│  Domain Layer              │  ➜ Entities, Value Objects, Commands, Services
└─────────────┬──────────────┘
              │ repository interfaces
┌─────────────▼──────────────┐
│  Infrastructure            │  ➜ AsyncStorage repos (swap‑able)
└────────────────────────────┘
```

_Benefits_: UI decoupled from business rules; tests can run on Node w/out RN; swapping `AsyncStorageMatchRepo` for `SupabaseMatchRepo` later requires no UI/store changes.

---

### **4 · Core Libraries**

| Concern         | Choice & Rationale                                                                                    |
| --------------- | ----------------------------------------------------------------------------------------------------- |
| **Bootstrap**   | `expo@latest` – fastest dev loop & OTA updates.                                                       |
| **Navigation**  | `@react-navigation/native` with Stack & Tab navigators.                                               |
| **State**       | `zustand` + `immer` + _custom_ undo/redo middleware.                                                  |
| **Validation**  | `zod` schemas shared by forms & persistence layer.                                                    |
| **Persistence** | `@react-native-async-storage/async-storage` behind `MatchRepository` / `PlayerRepository` interfaces. |
| **Timing**      | Simple `setInterval` (1 s) driven by persisted `startedAt`.                                           |
| **Testing**     | `vitest` + `@testing-library/react-native` + Detox (E2E).                                             |

---

### **5 · Domain Model**

```ts
/* player.ts */
export class Player {
  constructor(
    public readonly id: UUID,
    public name: string // No 'position' for v‑1; add later via migration
  ) {}
}

/* team.ts */
export class Team {
  constructor(
    public readonly id: UUID,
    public name: string,
    public members: Player[]
  ) {}
}

/* match-settings.ts */
export class MatchSettings {
  pointsToWin = 25; // configurable
  winBy = 2; // configurable
}

/* score-event.ts */
export class ScoreEvent {
  constructor(
    public readonly teamId: UUID,
    public readonly delta: 1 | -1,
    public readonly timestamp: Date = new Date()
  ) {}
}

/* set-result.ts */
export class SetResult {
  teamAScore = 0;
  teamBScore = 0;
  durationSec = 0;
  events: ScoreEvent[] = [];
}

/* match.ts */
export class Match {
  readonly id: UUID;
  readonly teams: [Team, Team];
  readonly sets: SetResult[] = [new SetResult()];
  readonly startedAt: Date = new Date();
  finishedAt?: Date;
  settings: MatchSettings;

  elapsed(now: Date = new Date()) {
    return (
      ((this.finishedAt ?? now).getTime() - this.startedAt.getTime()) / 1000
    );
  }
}
```

**Commands & Undo**

```ts
export interface Command {
  do(): void;
  undo(): void;
}

export class IncrementPointCmd implements Command {
  constructor(
    private matchId: UUID,
    private teamId: UUID,
    private repo: MatchRepository
  ) {}
  do() {
    this.repo.addScoreEvent(this.matchId, new ScoreEvent(this.teamId, +1));
  }
  undo() {
    this.repo.addScoreEvent(this.matchId, new ScoreEvent(this.teamId, -1));
  }
}
```

_Undo middleware_ maintains two stacks (`undoStack`, `redoStack`) capped at **200** elements.

---

### **6 · Zustand Store (excerpt)**

```ts
type StoreState = {
  matches: Map<UUID, Match>;
  currentMatchId: UUID | null;
  incPoint: (teamId: UUID) => void;
  undo: () => void;
  redo: () => void;
  /* ... */
};

export const useStore = create<StoreState>()(
  undoable(
    immer((set, get) => ({
      matches: new Map(),
      currentMatchId: null,

      incPoint: (teamId) =>
        get()._runCmd(
          new IncrementPointCmd(get().currentMatchId!, teamId, matchRepo)
        ),

      _runCmd: (cmd: Command) =>
        set((state) => {
          cmd.do();
          state.undoStack.push(cmd);
          if (state.undoStack.length > 200) state.undoStack.shift();
          state.redoStack = [];
        }),

      undo: () =>
        set((state) => {
          /* pop, cmd.undo() ... */
        }),
      redo: () =>
        set((state) => {
          /* pop, cmd.do() ...   */
        }),
    }))
  )
);
```

---

### **7 · Continuous Timer Hook**

```ts
export function useMatchTimer(matchId: UUID): number {
  const startedAt = useStore((s) => s.matches.get(matchId)?.startedAt);
  const finishedAt = useStore((s) => s.matches.get(matchId)?.finishedAt);
  const [now, setNow] = useState(() => new Date());

  useEffect(() => {
    if (!startedAt) return;
    const id = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(id);
  }, [startedAt]);

  if (!startedAt) return 0;
  const end = finishedAt ?? now;
  return Math.floor((end.getTime() - startedAt.getTime()) / 1000);
}
```

---

### **8 · Statistics Service**

```ts
export class StatsService {
  constructor(private readonly matches: Match[]) {}

  winRate(playerId: UUID) {
    const { wins, total } = this.matches.reduce(
      (acc, m) => {
        const lastSet = m.sets.at(-1)!;
        const teamAWon = lastSet.teamAScore > lastSet.teamBScore;
        const winner = teamAWon ? m.teams[0] : m.teams[1];
        if (winner.members.some((p) => p.id === playerId)) acc.wins++;
        if (m.teams.flatMap((t) => t.members).some((p) => p.id === playerId))
          acc.total++;
        return acc;
      },
      { wins: 0, total: 0 }
    );
    return total ? wins / total : 0;
  }

  longestWinStreak(playerId: UUID) {
    /* Kadane‑style scan */
  }

  averageMatchLength() {
    const finished = this.matches.filter((m) => m.finishedAt);
    const ms =
      finished.reduce((sum, m) => sum + m.elapsed(m.finishedAt!), 0) /
      finished.length;
    return ms / 1000; // seconds
  }
}
```

**Refresh strategy**: On **every match save/update**, a helper in the store runs:

```ts
set((state) => {
  state.stats = new StatsService([...state.matches.values()]).snapshot();
});
```

For casual volumes (< 5 000 matches) this takes ≤ 5 ms.

---

### **9 · Infrastructure & Swappable Repos**

```ts
export interface MatchRepository {
  save(match: Match): Promise<void>;
  find(id: UUID): Promise<Match | undefined>;
  list(): Promise<Match[]>;
  addScoreEvent(matchId: UUID, ev: ScoreEvent): void;
}

export class AsyncStorageMatchRepo implements MatchRepository {
  /* ... */
}
```

To add online sync later, create `SupabaseMatchRepo` that fulfills the same interface and register it via a simple provider:

```ts
export const matchRepo: MatchRepository = isOnline
  ? new SupabaseMatchRepo()
  : new AsyncStorageMatchRepo();
```

No other layer changes.

---

### **10 · Folder Structure**

```
src/
  app/                 Expo entry + theme/provider setup
  store/               Zustand store & undo middleware
  domain/              entities, commands, services
  infrastructure/
    repos/             asyncStorage/, (future) supabase/
  modules/
    score/             ScoreScreen, useTimer, point buttons
    history/           HistoryScreen, MatchCard
    stats/             StatsScreen, charts
    teams/             TeamGenerator, player CRUD
    settings/          SettingsScreen, zod schema
  ui/                  atomic components (Button, Card, etc.)
  test/                unit + integration specs
```

---

### **11 · Testing Matrix**

| Layer              | Frameworks                      | Coverage Target            |
| ------------------ | ------------------------------- | -------------------------- |
| Domain & Commands  | `vitest`                        | 95 %                       |
| Store & Middleware | `vitest` (JSDOM)                | 90 %                       |
| React UI           | `@testing-library/react-native` | Critical paths             |
| End‑to‑End         | **Detox** on iOS & Android      | Smoke scenarios            |
| Performance        | `react-native-performance`      | < 16 ms/frame Score screen |

CI (GitHub Actions): lint → unit tests → E2E (Android emulator) → build artifacts.

---

### **12 · Open for Future Iteration**

| Potential Feature    | Hook in Current Design                                                 |
| -------------------- | ---------------------------------------------------------------------- |
| Online multiplayer   | replace repositories + add WebSocket event bus                         |
| Additional sports    | `SportRules` strategy in Domain (`isGameOver`, `scoreFormat`)          |
| Elo rating           | new `RatingService` consuming match list; optional field on Player DTO |
| Theme / localisation | global context + `i18n‑js`; UI uses prop‑driven colours/fonts          |
| Export / import      | `MatchRepository.export(): JSON` & `import()`                          |

---

### **13 · Implementation Roadmap (Suggested 1‑Week Sprint)**

1. **Scaffold** Expo project, ESLint/Prettier, TS config.
2. Build **Domain entities + commands + in‑memory repo** with tests.
3. Implement **Zustand store** and undo middleware (cap 200).
4. Create **Score screen** with timer hook and tap zones.
5. Add **AsyncStorageMatchRepo** + History list/detail.
6. Integrate **StatsService**; surface stats in History detail & Stats screen.
7. Polish Settings UI (points‑to‑win & win‑by sliders).
8. Buffer: UX tweaks, performance profiling, E2E smoke tests.

---

#### **This document captures the final agreed‑upon design decisions.**

Feel free to point out anything that still looks off, and we can iterate further—otherwise you’re clear to start coding!
